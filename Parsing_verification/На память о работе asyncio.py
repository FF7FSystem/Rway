файл с расширением py только чтобы  коментарии не лезли в код (в текстовом все мешается в общую кучу)
В первой попытке программы работала такая

def main()
    prepare_data = task_list_prepare(task_num,for_connect)      # полчение перечня всех задач входящих в задание (в синхронном формате, потому что быстро)
    loop = asyncio.get_event_loop()                             # запуск планировщика  асинхронных задач
    loop.run_until_complete(gobaby(prepare_data,for_connect))   #помещение в планировщик основной задачи
    loop.close()                                                #закрытия планировщика задач после выполнения
    print()                                                     #закрытия планировщика задач после выполнения


async def gobaby(prepare_data,for_connect):
    futures = [task_full_info(args, for_connect) for args in task_list_prepare_data] #созадниае списка фьючерсов (функций, которые будут выполнены в асинхронном режиме)
    #Это и есть те финкии, которые будут получать данные о  качестве заполняемости по каждой задаче
    #В качестве аргументов передается параметры одной задачи из списка задач и свойства подключения в базе данных
    done, _ = await asyncio.wait(futures)   #Запуск всех ФУТУР !!!
    for_output=[]                           #Список в котором будут собираться результаты, формат - СПИСОК СЛОВАРЕЙ
    for future in done:                     #Если футура выполнена
        try:
            for_output.append(future.result())  #В результирующий список добавляются результат выполнения футуры
        except Exception as e:
            cprint(('Ошибка вот такая', e),'red')

    
gobaby  - Основная асинхронная  функиця создания и запуска других  асинхронных функций получения данных по задачам (в формате async).
Пришлось создать эту задачу, а не осуществлять данный код в функции main потому, что в main присутствует    вызов
обычной (синхронной) функции task_list_prepare для предварительного получения списка задач.
В таком случае main    не может быть асинхронной а как следствие не может создать и запустить другие асинхронные функции.
Либо необходимо единственныю синхронную функцию тоже делать условно асинхронной (что, как бы не нужно по сути,
она должна выполнится первой и делает это достаточно быстро)


Во второй попытке программа получила общий файл управления parsing_manage.py где самостоятельно запускалась та самая синхронная функция task_list_prepare, по этому код программы был переделан вот так.

def main()
    loop = asyncio.get_event_loop()                             # запуск планировщика  асинхронных задач
    futures = [task_full_info(args, for_connect) for args in prepare_data]  # созадниае списка фьючерсов (функций, которые будут выполнены в асинхронном режиме)
    done, _ = loop.run_until_complete(asyncio.wait(futures))   #помещение в планировщик основной задачи #Запуск всех ФУТУР !!!
    for_output=[]                           #Список в котором будут собираться результаты, формат - СПИСОК СЛОВАРЕЙ
    for future in done:                     #Если футура выполнена
        try:
            for_output.append(future.result())  #В результирующий список добавляются результат выполнения футуры
        except Exception as e:
            cprint(('Ошибка вот такая', e),'red')
    cprint((f'Общее время выполнения всех задач  = {(time.time() - begin):.1f}' + ' сек'), 'green')
    loop.close()                                                #закрытия планировщика задач после выполнения

