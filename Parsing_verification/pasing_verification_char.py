import pyodbc   #для связи с бд в синхронном виде
import aioodbc  #для связи с бд в асинхронном виде
import time
import datetime
import asyncio
from termcolor import cprint
import json
import os
from collections import Counter
import sql_querys   #Модуль содержащий текстовые sql запросы для использования ниже


file_path_of_result_data=[] #Путь к результирующему файлу для печати (из файла manage.py)

def task_list_prepare(task_num,for_connect):
    """
    запускается из manage.py
    Данная задача  при получении  номера задания task_num формирует список словарей содержащих данные по каждой задаче для
    дальнейшей передачи в асанхронную функцию и получения оценочных данных
    :param task_num:    Номер ЗАДАНИЯ или список задач
    :param for_connect: Настройки для подключения к базе данных
    :return: Возвращает список словарей содержащих данные по каждой задаче
    """
    task_list_prepare=[]            #активация итогового списка
    conn = pyodbc.connect(for_connect)  #подключение к базе
    cursor = conn.cursor()              #подключение к базе

    if isinstance(task_num,str): # Подготовка запроса, если передан номер задания
        cursor.execute(sql_querys.ALL_TASKS.format(task_num))  #Запрос к базе для получения списка всех задач и некоторых характеристик (_IDRRef,ДатаНачала,ДатаОкончания,Код задачи,Псевдоним,Статус,Шаблон)
        file_path_of_result_data.append(task_num)   #Запись номера задачи  (имени файла с результирующими данными), потом извлеку номер задачи и запишу полный путь

    elif isinstance(task_num,list): # Подготовка запроса, если передан список задач
        task_num = tuple(task_num) if len(task_num) > 1 else f"('{task_num[0]}')" #формирования task_num для запроса ниже (с учетом если в списке передан 1 или несколько элементов)
        cursor.execute(sql_querys.SOME_TASKS.format(task_num)) # Запрос к базе для получения предварительных характеристик по конкретным задачам
        file_path_of_result_data.append('-'.join(task_num[0].split('-')[:2])) #Запись номера задачи  (имени файла с результирующими данными), потом извлеку номер задачи и запишу полный путь
    else:
        raise Exception('В функицю task_list_prepare не переданы номер задания или задачи')

    list_task= cursor.fetchall()    #Результаты выполненого запроса, список, где хар-ки (_IDRRef,ДатаНачала,ДатаОкончания,Код задачи,Псевдоним,Статус,Шаблон) указаны позиционно

    for item in list_task:          #перебираем каждую строку, добавляем хар-ку "всего предложений",создаем словарь, чтобы обращаться к хар-кам не позицонно а по ключу
        # Для получения данных о количестве всех предложений по каждой задаче необходимо отредатировать хар _IDRRef
        # Преобразовать _IDRRef из байтового представления в целочисленное для подстановки в селект
        code_of_task='0x'+item[0].hex().upper()
        cursor.execute(sql_querys.CNT_OFFERS_PER_TASK.format(code_of_task)) #запрос в базу для получения количества предложений по данной задаче
        quantity=cursor.fetchall()[0][0]    #количеств предложений по данной задаче
        psevdonim=item[4]                   #псевдоним задачи или название источника, например "АВИТО"

        sub = ''
        if psevdonim == 'MOVE':         # есть задачи у которых одинаковый псевдоним, это значит что при выводе данных будет не понятно что это за источник и почему его несколько
            if 'ГорМил' in item[6]:     #Например задачи MOVE имеют одинаковый псевдоним но шаблоны инструкции по которым осуществляется парсинг
                sub = '_ГОРМИЛ'         #у них разные по этому в этом участке проверяется, если псевдоним МУВ, то к псевдониму добавляется
            elif 'Регионы' in item[6]:  #имя региона по которому осуществляется парсинг и указанному в имени шаблона
                sub = '_РЕГИОНЫ'        #так создается 3 источника с разными псевдонимами
            elif 'Москва' in item[6]:
                sub = '_МОСКВА'
        #Запись в результирующий список словаря с характеристиками по каждой задаче   {'Код задачи','Псевдоним','Дата начала','Дата окончания','Всего предложений','Статус выполнения')
        #'Статус выполнения':str(item[5]) данная характеристика преобразуется в строку, так как база данных возвращает ответ типа declare(2),
        # но на языке питона это вызов функции declare, которой тут , конечно нет. В результате тв данную хар-ку записывается число (1,2 или 3)
        task_list_prepare.append({'Код задачи':item[3],'Псевдоним':psevdonim+sub,'Дата начала':item[1],'Дата окончания':item[2],'Всего предложений':quantity,'Статус выполнения':str(item[5])})
    cursor.close()  #Закрытие подключения к базе
    conn.close()    #Закрытие подключения к базе
    return(task_list_prepare)

def load_reload(tsk_head,still_work_task,zero_cnt_task):
    """
    :param tsk_head: Имя задачи, оно же заглавие файла с логами
    :param still_work_task:     Еще работающие задачи
    :param zero_cnt_task:       Задачи, которые завершили работу  с нулевым парсингом предложений
    :return: Ничего не возвращает
    Записывает указанные выше параметры в текстовый файл, если файл с таким заглавием уже есть, то добавляет данные новой строкой.
    """
    zero_cnt_task_val=[[j for j in i] for i in zero_cnt_task][0] if zero_cnt_task else []
    for_output = str({f'{datetime.datetime.now().strftime("%H:%M:%S %d.%m.%Y")}':{'still_work': still_work_task, 'zero_cnt':zero_cnt_task_val }})+'\n'
    os.chdir(r'C:\Users\user1\Desktop\pasing_verification_RWAY\add_manage\logs')
    files = os.listdir()
    mod = 'a' if tsk_head+'.txt' in files else 'w' #либо создаем  либо дополням созданный файл
    with open(r'C:\Users\user1\Desktop\pasing_verification_RWAY\add_manage\logs\{}.txt'.format(tsk_head), mod, encoding='utf-8') as fp:
        fp.write(for_output)

def excluding_task(data):
    """
    запускается из manage.py
    функция принимает список задач в заданий. Некоторые источники запускаются несколько раз, для получения лучших
    результатов парсинга (больше спылесосить), по этому из тех источников которые парсились несколько раз нужно выбрать тот,
    у кого больше спарсино предложений.

    :param data: список задач в заданий с сопуствующими хар-ками.
    :return: отфильтрованный список
    """
    tsk_head = f'{data[0]["Код задачи"][:9]}' #Код задания для создания имени файла с логами
    task_counts = dict(Counter([i['Псевдоним'] for i in data])) #создается словарь в котором каждому истонику (ключ) соответствует число задач запущенных по этому источнику для парсинга
    execute_task, still_work_task, zero_cnt_task = [], [], []   #списки выполненых задач, еще работающих и с нулевым результатом.
    all_nickname = []
    filtered_list=[]   #итоговый список задач
    for item in data:
        if item['Всего предложений'] == 0 and item['Статус выполнения'] != '2': #задачи с нулевым числом спарсенных данных , но не выполненные (либо еще парсят, лиюо окончились с ошибкой)
            zero_cnt_task.append({item['Код задачи']:item['Псевдоним']})
        if item['Статус выполнения'] == '2':                                    #Выполненные задачи
            execute_task.append(item['Код задачи'])
        elif item['Статус выполнения'] == '1':                                  # задачи которые еще парсятся
            still_work_task.append(item['Код задачи'])

        if item['Псевдоним'] not in all_nickname:
            if  task_counts[item['Псевдоним']] == 1:        #Если задача с таким псевдонимом (Источник), запускалась только 1 раз, добаляется в результирующий список
                filtered_list.append(item)
            else:
                #Иначе, из всего списка задач выбираются с одним именем, сортируется по возрастанию предложений и берется первое значение (наибольшее)
                choice_items=[i for i in data if i['Псевдоним'] == item['Псевдоним']]
                new_item=sorted(choice_items,key=lambda x: x['Всего предложений'],reverse=True)[0]
                filtered_list.append(new_item)
            all_nickname.append(item['Псевдоним'])  #исписок источников по которым мы уже прошлись,
            # чтобы в случаи когда источник парсился не один раз не записывать егов результирующий список несколько раз
    load_reload(tsk_head,still_work_task,zero_cnt_task) #записывает лог в котором указывается  сколько задач и с каким статусом на данный момент в данном задании

    #Печать небольшой сатистики в терминал
    time_now = datetime.datetime.now().strftime("%H:%M")
    cprint("Задачи, которые завершили работу  с нулевым парсингом предложений:","red",end=' '),     print(zero_cnt_task)
    cprint(f"На {time_now} выполнено  задач: ", "green",end=''),                                    print(len(execute_task))
    cprint(f"На {time_now} в процессе парсинга находится задач:", "green",end=' '),                 print(len(still_work_task))
    return filtered_list


async def task_full_info(prepare_data,for_connect):
    """
    Основная функция (корутина) получения оценочных данных по каждой задаче.
    :param prepare_data: Словарь с данными о задаче полученых ранее  {'Код задачи','Псевдоним','Дата начала','Дата окончания','Всего предложений','Статус выполнения')
    :param for_connect: Настройки для подключения
    :return:  Возвращает список словарей с полными оценочными данными о заполнямости задачи (источника)
    """
    task_code=prepare_data['Код задачи']
    print(f'задача {task_code} начата')
    task_beg=time.time()
    conn = await aioodbc.connect(dsn=for_connect)   #Подключение к базе данных через асинхронный коннектор
    cursor = await conn.cursor()                    #Подключение к базе данных через асинхронный курсор
    '''Запросы SQL возвращают 1 строку без названий колонок, по этому приходится создавать списки названий колонок
    col_name с последующим создаванием словарей (Ключ = Имя колонки, значение = значение), путем  сопоставления двух списков
    колонок и ключей позиционно, что неочень хорошо.
    '''
    col_name_char1=(
        'Цена','Цена Предложения За 1 кв.м.','Размерность Стоимости','Продавец','Телефон Продавца','Общая Площадь Предложения',
        'Размерность Площади','Широта По Источнику','Долгота По Источнику','Заголовок','Способ Реализации','Этаж','Этажность',
        'Тип объекта недвижимости','Предмет Сделки','Класс Объекта','Назначение Объекта Предложения','Дата Сбора Информации')
    col_name_char2 = (
        'Адрес','ДатаРазмещения','Описание','СамаяРанняяДатаРазмещения','Сегмент','Подсегмент','СсылкаИсточника','Субъект',
        'ТипРынка','ТипСделки')
    try:
        try:
            #Запрос из бызы характеристик указанных в списке col_name_char1. Самый долгий запрос который блокирует обычную функцию на несколько минут
            #Сначала запрос скрепляет несколько таблиц разной формы (select Объект, Наименование,Значение). Одна из таблиц горизонтальная и для одного предложения
            #содержит одну строку и много колонок, другая таблица вертикальная и для одного предложения содержит одну колонку с множеством  строк
            #Чтобы создать одну таблицу характеристик предложения с одной строкой и множеством колонок используется конструкция  case
            #при этом,содержание колонок не учитывается, а проставляется 1 если ячейка заполнена и 0 если пустая (тут не проверяется качество заполнения, но проверяется количество (полнота))
            # Получается большая таблица со всеми предложениями  (строка) и их характеристиками (столбцы ) для данной задачи (источника) где все характеристики заполнены 1 или 0
            # Следующим этапом в полученой  таблице  подсчитываются все заполненные поля
            await cursor.execute(sql_querys.MAIN_QUERY_CHAR_1.format(task_code))

            result_sql_1= await cursor.fetchall()                   #Результаты запроса приходят в виде списка
            result_dict=dict(zip(col_name_char1, result_sql_1[0]))  #Создается словарь  где ключ это название хар-ки (col_name_char1), а значение это количество заполненыных предложений
        except Exception as e:
            cprint(f'Ошибка задачи {task_code} функциии task_full_info в запросе №1 = {e}', 'red')

        try:
            #Данный запрос похож на запрос выше, за исключеним того, что тут не нужно  соеденять таблицы 2-х форм
            # а результат аналогичный, но для  характеристик col_name_char2
            await cursor.execute(sql_querys.MAIN_QUERY_CHAR_2.format(task_code))
            result_sql_2 = await cursor.fetchall()                           #Результаты запроса приходят в виде списка
            result_dict.update(dict(zip(col_name_char2, result_sql_2[0])))   #Словарь  с характеристиками для задачи (созданный после первого запроса)  дополняется новыми характеристиками col_name_char2

        except Exception as e:
            cprint(f'Ошибка задачи {task_code} функциии task_full_info в запросе №2 = {e}', 'red')

        for key in result_dict:
            # Замена данных по характеристакам. Каждая характеристика представляется не как количество заполненных предложений
            # в источнике, а отношение всех общего количества к количеству заполненых (в процентах т.е. *100)
            #так для каждого источника получаются данные о процентном соотношении заполнености,
            # например  из 100 предложений по источнику АВИТО только у 90% предложений заполнена характеристика "ЦЕНА"
            if int(prepare_data['Всего предложений']) != 0:  # Дабы небыло деления на 0 в случае когда всего предложений  = 0
                val = result_dict[key] / int(prepare_data['Всего предложений']) * 100
            else:
                val = 0
            result_dict[key] = f'{val:.2f}'

    except Exception as e:
        cprint(f'Ошибка задачи {task_code} {e}', 'red')
    finally:
        result_dict.update(prepare_data) #Результирующий словарь с оценками заполняемости дополняется начальными данными {'Код задачи','Псевдоним','Дата начала','Дата окончания','Всего предложений','Статус выполнения')

        await cursor.close()    #закрытие соединения с базой данных
        await conn.close()      #закрытие соединения с базой данных
        cprint((f'задача {task_code} выполнена за  = {(time.time() - task_beg):.1f}' + ' сек'), 'cyan')
        return result_dict

def main(prepare_data,for_connect):
    """
    :task_list_prepare: Данные подготовленные ранее (перечн всех задач входящих в задание  с дополнительной инфой)
    :for_connect:   настройки подключения к базе SQL
    Скрипт предназначен для  получения оценочных данных результатов парсинга. конкретного ЗАДАНИЯ из базы данных RWAY.
    Задание включает в себя определенное количество задач парсинга. (задачи не парсинга = обрадотки фильтруются на стадии sql запросов)
    Каждая задача парсит конкретный источник данных, например сайт АВИТО и содержит определенное количество предложений.
    Каждое предложение содержит ряд ключевых характеристик, без которых предложение не имеет ценности.
    Результаты парсинга представлены как процентное соотношение заполнения ключевых  характеристик по отношению к общему количеству предложений по этой задаче(источнику).
    :return:  Скрипт который ничего не возвращает в виде результата. Записывает все данные в файл формата json и
    сохраняет путь к файлу в переменной file_path_of_result_data, которая  использоваться для печати в терминал в другой части скрипта (из файла управления)
     """
    begin = time.time()  # условное время начала запуска скрипта
    loop = asyncio.get_event_loop()                             # запуск планировщика  асинхронных задач
    futures = [task_full_info(args, for_connect) for args in prepare_data]  # созадниае списка фьючерсов (функций, которые будут выполнены в асинхронном режиме)
    done, _ = loop.run_until_complete(asyncio.wait(futures))   #помещение в планировщик основной задачи #Запуск всех ФУТУР !!!
    for_output=[]                           #Список в котором будут собираться результаты, формат - СПИСОК СЛОВАРЕЙ
    for future in done:                     #Если футура выполнена
        try:
            for_output.append(future.result())  #В результирующий список добавляются результат выполнения футуры
        except Exception as e:
            cprint(('Ошибка вот такая', e),'red')
    cprint((f'Общее время выполнения всех задач  = {(time.time() - begin):.1f}' + ' сек'), 'green')
    loop.close()                                                #закрытия планировщика задач после выполнения

    #Запись файла с результатами парсинга
    file_path=r'C:\Users\user1\Desktop\pasing_verification_RWAY\add_manage\parse_result\{}.json'.format(file_path_of_result_data.pop())
    with open(file_path, 'w', encoding='utf-8') as fp:
        json.dump(for_output, fp, ensure_ascii=False, indent=4)
    file_path_of_result_data.append(file_path)    #Путь к результирующему файлу для печати



if __name__ == "__main__":

    #Для отладки
    task_num = '0001-0661'
    # task_num = ['0001-0649-0014']
    # for_connect = 'DRIVER={SQL Server};SERVER=10.199.13.60;DATABASE=rway;UID=vdorofeev;PWD=Sql01'  #Настройки подключения к базе RWAY, будет использовано для подключения в синхронной и асинхронной функциях
    for_connect = 'DRIVER={SQL Server};SERVER=10.199.13.57;DATABASE=rway;UID=vdorofeev;PWD=VD12345#'  # Настройки подключения к базе RWAY, будет использовано для подключения в синхронной и асинхронной функциях
    """ Нельзя передавать одно подключение в потоки (aioodbc.connect(dsn=for_connect) или pyodbc.connect(for_connect)), первый поток выполнится а другие скажут что соединение занято
        Нельзя передавать в потоки один курсор (conn.cursor()), первый поток выполнится а другие сойдут с ума т.к. курсор переместится в первом потоке
        Но можно передать простую строку настроек которая будет использована  при каждом подключении к серверу SQL
    """
    prepare_data = task_list_prepare(task_num= task_num ,for_connect = for_connect)  # получение перечня всех задач входящих в задание (в синхронном формате, потому что быстро)
    main(prepare_data,for_connect)

    import pasing_print
    with open(file_path_of_result_data[0], 'r', encoding='utf-8') as fp:
        for_print=json.load(fp)
    try:
        pasing_print.main(for_print)
    except Exception as e:
        cprint(f'Ошибка в модуле pasing_print вот такая {e}','red')